**ES6~ES13新特性（一） ![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.001.png)![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.002.png)![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.003.png)**

王红元 coderwhy![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.004.png)

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.005.png) ![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.006.png)

|**目录 content**|**1![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.007.png)**|**ECMA新描述概念**|
| :- | - | - |
||**2![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.008.png)**|**let、const 的使用**|
||**3![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.009.png)**|**let、const 和var 区别**|
||**4![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.010.png)**|**块级作用域的使用**|
||**5![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.011.png)**|**模板字符串的详解**|
||**6![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.012.png)**|**ES6函数的增强用法**|

**新的ECMA代码执行描述![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在执行学习JavaScript 代码执行过程中，我们学习了很多 ECMA文档的术语：
  - 执行上下文栈：Execution Context Stack ，用于执行上下文的栈结构；
  - 执行上下文：Execution Context，代码在执行之前会先创建对应的执行上下文；
  - 变量对象：Variable Object ，上下文关联的VO 对象，用于记录函数和变量声明；
  - 全局对象：Global Object ，全局执行上下文关联的VO 对象；
  - 激活对象：Activation Object，函数执行上下文关联的VO 对象；
  - 作用域链：scope chain，作用域链，用于关联指向上下文的变量查找；
- 在新的ECMA 代码执行描述中（ ES5以及之上），对于代码的执行流程描述改成了另外的一些词汇：
- 基本思路是相同的，只是对于一些词汇的描述发生了改变；
- 执行上下文站和执行上下文也是相同的；

**词法环境（Lexical Environments ）![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 词法环境是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符；
- 一个词法环境是由环境记录（Environment Record ）和一个外部词法环境（ o*ute;r* Lexical Environment）组成；
- 一个词法环境经常用于关联一个函数声明、代码块语句、try -catch语句，当它们的代码被执行时，词法环境被创建出来；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.014.png)

- 也就是在ES5 之后，执行一个代码，通常会关联对应的词法环境；
- 那么执行上下文会关联哪些词法环境呢？

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.015.png)

**LexicalEnvironment和VariableEnvironment![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- LexicalEnvironment用于存放let、const声明的标识符：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.016.png)

- VariableEnvironment用于存放var 和function声明的标识符：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.017.png)

**环境记录（Environment Record）![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在这个规范中有两种主要的环境记录值 :声明式环境记录和对象环境记录。
- 声明式环境记录：声明性环境记录用于定义ECMAScript 语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定与 ECMAScript语言值关联起来的Catch 子句。
- 对象式环境记录：对象环境记录用于定义ECMAScript 元素的效果，例如 WithStatement，它将标识符绑定与某些对象的属性 关联起来。

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.018.png)

**let/const基本使用![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在ES5 中我们声明变量都是使用的var 关键字，从 ES6开始新增了两个关键字可以声明变量： let、const
  - let、const 在其他编程语言中都是有的，所以也并不是新鲜的关键字；
  - 但是let、const 确确实实给JavaScript 带来一些不一样的东西；
- let关键字：
  - 从直观的角度来说，let和var 是没有太大的区别的，都是用于声明一个变量
- const关键字：
  - const关键字是 constant的单词的缩写，表示常量、衡量的意思；
  - 它表示保存的数据一旦被赋值，就不能被修改；
  - 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容；
- 注意：另外let、const 不允许重复声明变量；

**let/const作用域提升![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- let、const 和var 的另一个重要区别是作用域提升：
- 我们知道var 声明的变量是会进行作用域提升的；
- 但是如果我们使用let声明的变量，在声明之前访问会报错；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.019.png)

- 那么是不是意味着foo变量只有在代码执行阶段才会创建的呢？
- 事实上并不是这样的，我们可以看一下 ECMA262对let和const 的描述；
- **这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值；**

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.020.png)

**let/const有没有作用域提升呢？![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 从上面我们可以看出，在执行上下文的词法环境创建出来的时候，变量事实上已经被创建了，只是这个变量是不能被访问的。
  - 那么变量已经有了，但是不能被访问，是不是一种作用域的提升呢？
- 事实上维基百科并没有对作用域提升有严格的概念解释，那么我们自己从字面量上理解；
- **作用域提升：**在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升；
- 在这里，它虽然被创建出来了，但是不能被访问，我认为不能称之为作用域提升；
- 所以我的观点是let、const没有进行作用域提升，但是会在解析阶段被创建出来。

**Window对象添加属性![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 我们知道，在全局通过var 来声明一个变量，事实上会在window 上添加一个属性：
  - 但是let、const 是不会给window 上添加任何属性的。
- 那么我们可能会想这个变量是保存在哪里呢？
- 我们先回顾一下最新的ECMA 标准中对执行上下文的描述

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.021.png)

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.022.png)

**变量被保存到VariableMap中![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 也就是说我们声明的变量和环境记录是被添加到变量环境中的：
- 但是标准有没有规定这个对象是 window对象或者其他对象呢？
- 其实并没有，那么JS 引擎在解析的时候，其实会有自己的实现；
- 比如v8 中其实是通过 VariableMap的一个 hashmap来实现它们的存储的。
- 那么window 对象呢？而window 对象是早期的 GO对象，在最新的实现中其实是浏览器添加的全局对象，并且一直保持了 window和var 之间值的相等性；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.023.png)

**var的块级作用域![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在我们前面的学习中，JavaScript 只会形成两个作用域：全局作用域和函数作用域。

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.024.png)

- ES5中放到一个代码中定义的变量，外面是可以访问的：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.025.png)

**let/const的块级作用域![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在ES6 中新增了块级作用域，并且通过 let、const、function、class 声明的标识符是具备块级作用域的限制的：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.026.png)

- 但是我们会发现函数拥有块级作用域，但是外面依然是可以访问的：
- 这是因为引擎会对函数的声明进行特殊的处理，允许像var 那样进行提升；

**块级作用域的应用![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 我来看一个实际的案例：获取多个按钮监听点击

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.027.png)

- 使用let或者const 来实现：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.028.png)

**var、let 、const 的选择![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 那么在开发中，我们到底应该选择使用哪一种方式来定义我们的变量呢？
- 对于var 的使用：
- 我们需要明白一个事实， var所表现出来的特殊性：比如作用域提升、window 全局对象、没有块级作用域等都是一些历史遗 留问题；
- 其实是JavaScript 在设计之初的一种语言缺陷；
- 当然目前市场上也在利用这种缺陷出一系列的面试题，来考察大家对JavaScript 语言本身以及底层的理解；
- 但是在实际工作中，我们可以使用最新的规范来编写，也就是不再使用var 来定义变量了；
- 对于let、const ：
- 对于let和const 来说，是目前开发中推荐使用的；
- 我们会有限推荐使用const ，这样可以保证数据的安全性不会被随意的篡改；
- 只有当我们明确知道一个变量后续会需要被重新赋值时，这个时候再使用 let；
- 这种在很多其他语言里面也都是一种约定俗成的规范，尽量我们也遵守这种规范；

**字符串模板基本使用![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在ES6 之前，如果我们想要将字符串和一些动态的变量（标识符）拼接到一起，是非常麻烦和丑陋的（ugly ）。
- ES6允许我们使用字符串模板来嵌入JS 的变量或者表达式来进行拼接：
- 首先，我们会使用**   符号来编写字符串，称之为模板字符串；
- 其次，在模板字符串中，我们可以通过 **${expression}** 来嵌入动态的内容；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.029.png)

**标签模板字符串使用![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 模板字符串还有另外一种用法：标签模板字符串（Tagged Template Literals ）。
- 我们一起来看一个普通的 JavaScript的函数：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.030.png)

- 如果我们使用标签模板字符串，并且在调用的时候插入其他的变量：
- 模板字符串被拆分了；
- 第一个元素是数组，是被模块字符串拆分的字符串组合；
- 后面的元素是一个个模块字符串传入的内容；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.031.png)

**React的styled-components 库![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.032.png)

**函数的默认参数![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在ES6 之前，我们编写的函数参数是没有默认值的，所以我们在编写函数时，如果有下面的需求：
  - 传入了参数，那么使用传入的参数；
  - 没有传入参数，那么使用一个默认值；
- 而在ES6 中，我们允许给函数一个默认值：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.033.png)

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.034.png)


**函数默认值的补充![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 默认值也可以和解构一起来使用：

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.035.png)

- 另外参数的默认值我们通常会将其放到最后（在很多语言中，如果不放到最后其实会报错的）：
  - 但是JavaScript 允许不将其放到最后，但是意味着还是会按照顺序来匹配；
- 另外默认值会改变函数的 length的个数，默认值以及后面的参数都不计算在length之内了。

**函数的剩余参数![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- ES6中引用了rest parameter ，可以将不定数量的参数放入到一个数组中：
- 如果最后一个参数是 ... 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.036.png)

- **那么剩余参数和arguments 有什么区别呢？**
- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参 ；
- arguments对象不是一个真正的数组，而 rest参数是一个真正的数组，可以进行数组的所有操作；
- arguments是早期的ECMAScript 中为了方便去获取所有的参数提供的一个数据结构，而rest 参数是ES6 中提供 并且希望以此 来替代arguments 的；
- 剩余参数必须放到最后一个位置，否则会报错。


**函数箭头函数的补充![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.013.png)**

- 在前面我们已经学习了箭头函数的用法，这里进行一些补充：
- 箭头函数是没有显式原型的，所以不能作为构造函数，使用 new来创建对象；

![](image/Aspose.Words.a7a64add-9227-4e3f-bcff-06cc967d049e.037.png)
