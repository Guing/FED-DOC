## vue-cli本身问题

单页面无法做到SEO搜索优化：

- 无法做到多页面

- title、描述、关键词是动态的

- 网站内容是动态加载的

解决方法有两种：

- 预渲染
- 服务端渲染

## 预渲染

流程演示：

![预渲染图解](image/%E9%A2%84%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A7%A3.png)

如何做：

- 多页面预先渲染，使用插件：`prerender-spa-plugin`

  - vue项目中安装`prerender-spa-plugin`

  - vue.config.js进行配置

- 静态修改title描述关键词：vue-meta-info
  - 下载`npm install vue-meta-info -S`
  - 到页面组件中配置

```js
metaInfo: {
title: '小鹿线官网', 
meta: [{               
    name: '关键字,web前端',
    content: '描述'
  }]
}
```

解决什么问题：

- 打包多页面，
- 解决每个页面单独生成title描述关键词 [vue-meta-info]

- 接口数据是在html生成之前就放在页面上的，爬虫可以抓取到内容

存在的问题：
 - 预渲染无法配置动态路由
 - 如果title描述关键词来自于接口的数据，配置到meta-info也是不行的

适合做什么项目：
- 一个项目可能某几个页面需要做seo，比如只做首页SEO，其他页面不需要

## 服务端渲染

流程演示：

![服务端渲染](image/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.jpg)

如何做：

- 使用Nuxt.js

适合做什么项目：

- 一个项目可能所有页面都要做seo

## 解决seo的方案选择



前后端不分离：

- 传统的后端模板，比如JSP等

- 压力在后端
- 好处：安全

前后端分离的：

- spa单页面应用[vue-cli本身处理不了seo]
  - 压力客户端
- 预渲染
  - 压力客户端
  - 问题：
    - 在html页面加载之前数据过来渲染后才有html的dom结构，这样的话可能也会存在页面空白的情况
    - 一个项目不是所有页面都做seo
- 服务端渲染   
  - 压力客户端
  - 问题：
    - 起了2个服务 [一个是后端自己语言的服务，一个是nodejs的服务]

## nuxt安装和目录结构
安装过程中的选项：

- Programming language:   程序设计语言

- Package manager:   包管理器
- UI framework:ui框架
- Nuxt.js modules:   nuxt的js模块
- Linting tools:代码校验工具
- Testing framework:   测试框架
- Rendering modules  :渲染模式
- Deployment target:   部署目标
- Development tools   :   开发工具
- Version control system :   版本控制工具

目录结构：

- pages  :  存放页面，类似于src/views
- components  :  存放组件，类似于src/components
- static:  存放静态资源，类似于src/assets
- store:  vuex状态树，类似于src/store
- nuxt.config.js  : 全局的配置文件，类似于vue.config.js

## nuxt生命周期

![img](https://nuxtjs.org/_nuxt/image/de48ca.svg)

`nuxt`生命周期是在`nuxt`项目构建完成后，用户在客户端数据`url`后的一些列动作，由先到后的执行顺序如下（以下是基于`SSR`服务端渲染）：`nuxt start`，服务端启动项目后，服务端中加载`Nuxt`、中间件以及`Nuxt`插件（`Nuxt`插件的引入根据`nuxt.config.js`中定义的先后顺序），下面进入到生命周期：

### 服务端生命周期

#### nuxtServerInit

- 服务端中运行，每个页面都执行
- 有两个参数，第一个是`Vuex`的上下文，第二个是`Nuxt`的`context`， `Vuex`用于预填存储状态；

- 该钩子在`store/index.js`中定义

- 类似于vue.js中的main.js。可以在这个生命周期中获取token，并存储。

```js
export const state = {
	token:''
}
export const mutations = {
	setToken(state,token){
		state.token = token;
	}
}
export const actions = {
	nuxtServerInit(store , context ){
		store.commit('setToken','')
		console.log( 'nuxtServerInit' );
	}
}
```



#### Middleware

- 在服务端运行，在每个页面都执行
- middleware({store,route,redirect,params,query,req,res}){} 

- 执行顺序为：

  - **全局中间件**（在`nuxt.config.js`中定义: `router: { middleware: ['auth']}`）
  - **布局中间件**（`layouts`中定义）
  - **路由中间件**（在`page`中定义，通过`middleware: 'auth'`）；

- 类似于vue.js中的导航守卫，可以在这个生命周期中进行用户是否登录判断

- 中间件写法为:

  - 第一种写法：

  ```js
   
  export default {
  	middleware:'auth'
  }
  //新建middleware目录 ==> auth.js
  ```

  - 第一种写法：

```js
//直接写函数
export default {
	middleware(){
	  	
	}
}
```

#### validate

- 在服务端运行，在每个页面都执行，只能在页面中定义；
- validate({params,query}){} 

- 在页面渲染之前执行；用于校验动态路由参数是否合法，必须返回布尔值（`true`或`false`)，true为通过，false则跳到错误页面。

```js
export default {
  validate({params,query}){
    console.log('validate');
    return /^\d+$/.test(query.id);
  }
}
```

#### asyncData

- 在服务端运行，在每个页面都执行，只能在页面中定义，不能用于组件

- 读取数据，返回给组件,这里我们可以做一些异步的数据请求，返回给组件。

- 传参为**当前页面的上下文对象**，并且支持给`data`赋值，方法最后`return`出来即可；

- 该方法在页面初始化之前执行，因此无法获取`this`组件示例

#### fetch

- 在服务端运行，在每个页面都执行，可以在页面、组件中都能使用

- `Nuxt2.12`之后新增钩子，同`asyncData`一样，只不过返回数据给redux状态树。
- 传参为**当前页面的上下文对象**，但是无法为`data`赋值，可以拿到`Vuex`上下文，用于在页面渲染之前预设`store`状态树；
- `fetch()`在页面渲染之前执行，因此此时无法获取`this`组件示例

### 服务端和客户端共有生命周期

#### beforeCreate

- `beforeCreate`:` Vue`实例注册完成之后执行；运行环境包括服务端和客户端，用法同`vue`差不多；

#### created

- `created`: `Vue`示例创建完成之后执行；运行环境包括服务端和客户端，用法同`vue`差不多；

### 客户端生命周期

- beforeMount: 此时，DOM节点可用，fetch()方法也已完成，即pending=false；该钩子只在客户端运行，用法同 vue；
- mounted： 用法同 vue
- beforeUpadate： 用法同 vue
- updated： 用法同 vue
- beforeDestroy： 用法同 vue
- destroyed： 用法同 vue