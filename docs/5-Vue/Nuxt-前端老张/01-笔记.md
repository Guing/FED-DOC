## vue-cli本身问题

单页面无法做到SEO搜索优化：

- 无法做到多页面

- title、描述、关键词是动态的

- 网站内容是动态加载的

解决方法有两种：

- 预渲染
- 服务端渲染

## 预渲染

流程演示：

![预渲染图解](image/%E9%A2%84%E6%B8%B2%E6%9F%93%E5%9B%BE%E8%A7%A3.png)

如何做：

- 多页面预先渲染，使用插件：`prerender-spa-plugin`

  - vue项目中安装`prerender-spa-plugin`

  - vue.config.js进行配置

- 静态修改title描述关键词：vue-meta-info
  - 下载`npm install vue-meta-info -S`
  - 到页面组件中配置

```js
metaInfo: {
title: '小鹿线官网', 
meta: [{               
    name: '关键字,web前端',
    content: '描述'
  }]
}
```

解决什么问题：

- 打包多页面，
- 解决每个页面单独生成title描述关键词 [vue-meta-info]

- 接口数据是在html生成之前就放在页面上的，爬虫可以抓取到内容

存在的问题：
 - 预渲染无法配置动态路由
 - 如果title描述关键词来自于接口的数据，配置到meta-info也是不行的

适合做什么项目：
- 一个项目可能某几个页面需要做seo，比如只做首页SEO，其他页面不需要

## 服务端渲染

流程演示：

![服务端渲染](image/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.jpg)

如何做：

- 使用Nuxt.js

适合做什么项目：

- 一个项目可能所有页面都要做seo

## 解决seo的方案选择



前后端不分离：

- 传统的后端模板，比如JSP等

- 压力在后端
- 好处：安全

前后端分离的：

- spa单页面应用[vue-cli本身处理不了seo]
  - 压力客户端
- 预渲染
  - 压力客户端
  - 问题：
    - 在html页面加载之前数据过来渲染后才有html的dom结构，这样的话可能也会存在页面空白的情况
    - 一个项目不是所有页面都做seo
- 服务端渲染   
  - 压力客户端
  - 问题：
    - 起了2个服务 [一个是后端自己语言的服务，一个是nodejs的服务]

## nuxt安装和目录结构
安装过程中的选项：

- Programming language:   程序设计语言

- Package manager:   包管理器
- UI framework:ui框架
- Nuxt.js modules:   nuxt的js模块
- Linting tools:代码校验工具
- Testing framework:   测试框架
- Rendering modules  :渲染模式
- Deployment target:   部署目标
- Development tools   :   开发工具
- Version control system :   版本控制工具

目录结构：

- pages  :  存放页面，类似于src/views
- components  :  存放组件，类似于src/components
- static:  存放静态资源，类似于src/assets
- store:  vuex状态树，类似于src/store
- nuxt.config.js  : 全局的配置文件，类似于vue.config.js

## nuxt生命周期

![img](https://nuxtjs.org/_nuxt/image/de48ca.svg)

`nuxt`生命周期是在`nuxt`项目构建完成后，用户在客户端数据`url`后的一些列动作，由先到后的执行顺序如下（以下是基于`SSR`服务端渲染）：`nuxt start`，服务端启动项目后，服务端中加载`Nuxt`、中间件以及`Nuxt`插件（`Nuxt`插件的引入根据`nuxt.config.js`中定义的先后顺序），下面进入到生命周期：

### 服务端生命周期

#### nuxtServerInit

- 服务端中运行，每个页面都执行
- 有两个参数，第一个是`Vuex`的上下文，第二个是`Nuxt`的`context`， `Vuex`用于预填存储状态；

- 该钩子在`store/index.js`中定义

- 类似于vue.js中的main.js。可以在这个生命周期中获取token，并存储。

```js
export const state = {
	token:''
}
export const mutations = {
	setToken(state,token){
		state.token = token;
	}
}
export const actions = {
	nuxtServerInit(store , context ){
		store.commit('setToken','')
		console.log( 'nuxtServerInit' );
	}
}
```



#### Middleware

- 在服务端运行，在每个页面都执行
- middleware({store,route,redirect,params,query,req,res}){} 

- 执行顺序为：

  - **全局中间件**（在`nuxt.config.js`中定义: `router: { middleware: ['auth']}`）
  - **布局中间件**（`layouts`中定义）
  - **路由中间件**（在`page`中定义，通过`middleware: 'auth'`）；

- 类似于vue.js中的导航守卫，可以在这个生命周期中进行用户是否登录判断

- 中间件写法为:

  - 第一种写法：

  ```js
   
  export default {
  	middleware:'auth'
  }
  //新建middleware目录 ==> auth.js
  ```

  - 第二种写法：

```js
//直接写函数
export default {
  middleware(){

  }
}
```

#### validate

- 在服务端运行，在每个页面都执行，只能在页面中定义；
- validate({params,query}){} 

- 在页面渲染之前执行；用于校验动态路由参数是否合法，必须返回布尔值（`true`或`false`)，true为通过，false则跳到错误页面。

```js
export default {
  validate({params,query}){
    console.log('validate');
    return /^\d+$/.test(query.id);
  }
}
```

#### asyncData

- 在服务端运行，在每个页面都执行，**只能在页面中定义，不能用于组件**

- 读取数据，返回给页面，这里我们可以做一些异步的数据请求，返回给组件。

- 传参为**当前页面的上下文对象**，并且支持给`data`赋值，方法最后`return`出来即可；

- 该方法在页面初始化之前执行，**因此无法获取`this`**

#### fetch

- 在服务端运行，在每个页面都执行。`Nuxt2.12`之后新增钩子，可以在页面、组件中都能使用

- **在页面上使用**

  - 同`asyncData`类似，方法用于在渲染页面前填充应用的状态树（store）数据*，*不同的是它不会设置页面的数据。
  - 传参为**当前页面的上下文对象**，但是无法为`data`赋值，可以拿到`Vuex`上下文，用于在页面渲染之前预设`store`状态树；
  - 无法使用`this`。

  ```js
  async fetch({ $axios,store }){
       const data = await $axios.get("https://dog.ceo/api/breeds/image/random");
        store.commit('setToken',data.data.message)
     
    },
  ```

  

- **在组件上使用**

  - 可以设置组件的数据，可以使用`this.data=xxx`
  - 不能设置函数的传参，不然会失效，可以通`this.$store`获取vuex数据
  - 可以使用this

  ```js
   async fetch(/*context*/ ){ //不能设置context参数，不然这个方法会失效
  		let res = await this.$axios.get('http://testapi.xuexiluxian.cn/api/slider/getSliders');
  	  	let items = res.data.data.list;
        this.$store.commit('setToken',items[0].createTime)
  	  	this.items = items;
   
  	}
  ```

  

- 为了让获取过程可以异步，你需要**返回一个 Promise**，Nuxt.js 会等这个 promise 完成后再渲染组件。

  ```js
  <template>
    <h1>Stars: {{ $store.state.stars }}</h1>
  </template>
  
  <script>
    export default {
      fetch({ store, params }) {
        return axios.get('http://my-api/stars').then(res => {
          store.commit('setStars', res.data)
        })
      }
    }
  </script>
  ```

  

- `fetch`会在组件每次加载前被调用（在服务端或切换至目标路由之前）执行，因此

### 服务端和客户端共有生命周期

这两种方法都会执行两次。

#### beforeCreate

- `beforeCreate`:` Vue`实例注册完成之后执行；运行环境包括服务端和客户端，用法同`vue`差不多；

#### created

- `created`: `Vue`示例创建完成之后执行；运行环境包括服务端和客户端，用法同`vue`差不多；

### 客户端生命周期

- beforeMount: 此时，DOM节点可用，fetch()方法也已完成，即pending=false；该钩子只在客户端运行，用法同 vue；
- mounted： 用法同 vue
- beforeUpadate： 用法同 vue
- updated： 用法同 vue
- beforeDestroy： 用法同 vue
- destroyed： 用法同 vue

## asyncData与fetch区别

- 相同点
  - 都是在页面渲染之前，用来拉取异步数据

- 不同点
  - asyncData仅在页面使用，fetch可以在页面与组件上使用
  - asyncData比fetch先执行，但两个异步是同时进行
  - fetch在页面上使用是设置vuex数据，不可以设置页面数据；在组件上即可以设置vuex数据，又可以设置组件数据。asyncData则即可以设置vuex数据，又可以设置页面数据

## nuxt路由

### 自动生成

 文档链接： [https://www.nuxtjs.cn/guide/routing](https://www.nuxtjs.cn/guide/routing)

- Nuxt.js 依据 `pages` 目录结构自动生成 [vue-router](https://github.com/vuejs/vue-router) 模块的路由配置。
- 自动生成的路由配置在.nuxt文件夹中的router.js

- 要在页面之间使用路由，我们建议使用`<nuxt-link>`标签。

#### 基础路由

假设 `pages` 的目录结构如下：

```bash
pages/
--| user/
-----| index.vue
-----| one.vue
--| index.vue
```

那么，Nuxt.js 自动生成的路由配置如下：

```js
router: {
  routes: [
    {
      name: 'index',
      path: '/',
      component: 'pages/index.vue'
    },
    {
      name: 'user',
      path: '/user',
      component: 'pages/user/index.vue'
    },
    {
      name: 'user-one',
      path: '/user/one',
      component: 'pages/user/one.vue'
    }
  ]
}
```

#### 动态路由

在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的**以下划线作为前缀**的 Vue 文件 或 目录。

以下目录结构：

```bash
pages/
--| _slug/
-----| comments.vue
-----| index.vue
--| users/
-----| _id.vue
```

Nuxt.js 生成对应的路由配置表为：

```js
router: {
  routes: [
   
    {
      name: 'users-id',
      path: '/users/:id?',
      component: 'pages/users/_id.vue'
    },
    {
      name: 'slug',
      path: '/:slug',
      component: 'pages/_slug/index.vue'
    },
    {
      name: 'slug-comments',
      path: '/:slug/comments',
      component: 'pages/_slug/comments.vue'
    }
  ]
}
```

你会发现名称为 `users-id` 的路由路径带有 `:id?` 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 `users/_id` 目录内创建一个 `index.vue` 文件。

#### 嵌套路由

- 你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。

- 创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个**与该文件同名**的目录用来存放子视图组件。

- 别忘了在父组件(`.vue`文件) 内增加 `<nuxt-child/>` 用于显示子视图内容。

假设文件结构如：

```bash
pages/
--| users/
-----| _id.vue
-----| index.vue
--| users.vue
```

Nuxt.js 自动生成的路由配置如下：

```js
router: {
  routes: [
    {
      path: '/users',
      component: 'pages/users.vue',
      children: [
        {
          path: '',
          component: 'pages/users/index.vue',
          name: 'users'
        },
        {
          path: ':id',
          component: 'pages/users/_id.vue',
          name: 'users-id'
        }
      ]
    }
  ]
}
```

#### 动态嵌套路由

这个应用场景比较少见，但是 Nuxt.js 仍然支持：在动态路由下配置动态子路由。

假设文件结构如下：

```bash
pages/
--| _category/
-----| _subCategory/
--------| _id.vue
--------| index.vue
-----| _subCategory.vue
-----| index.vue
--| _category.vue
--| index.vue
```

Nuxt.js 自动生成的路由配置如下：

```js
router: {
  routes: [
    {
      path: '/',
      component: 'pages/index.vue',
      name: 'index'
    },
    {
      path: '/:category',
      component: 'pages/_category.vue',
      children: [
        {
          path: '',
          component: 'pages/_category/index.vue',
          name: 'category'
        },
        {
          path: ':subCategory',
          component: 'pages/_category/_subCategory.vue',
          children: [
            {
              path: '',
              component: 'pages/_category/_subCategory/index.vue',
              name: 'category-subCategory'
            },
            {
              path: ':id',
              component: 'pages/_category/_subCategory/_id.vue',
              name: 'category-subCategory-id'
            }
          ]
        }
      ]
    }
  ]
}
```

#### 未知嵌套深度的动态嵌套路由

如果您不知道 URL 结构的深度，您可以使用`_.vue`动态匹配嵌套路径。这将处理与*更具体*请求不匹配的情况。

文件结构:

```bash
pages/
--| people/
-----| _id.vue
-----| index.vue
--| _.vue
--| index.vue
```

将处理这样的请求：

| Path                     | File               |
| ------------------------ | ------------------ |
| `/`                      | `index.vue`        |
| `/people`                | `people/index.vue` |
| `/people/123`            | `people/_id.vue`   |
| `/about`                 | `_.vue`            |
| `/about/careers`         | `_.vue`            |
| `/about/careers/chicago` | `_.vue`            |

**Note:** 处理 404 页面，现在符合`_.vue`页面的逻辑。

#### 手动配置路由

- 使用` @nuxtjs/router `插件

- 在nuxt.config.js的modules模块进行配置

  ```js
  modules: [
    '@nuxtjs/router'
   ],
  ```

- 在根目录下使用router.js文件配置路由
- nuxtjs/router返回的内容和vue有所不同

```js
 export function createRouter() {

   return new VueRouter({

   mode: 'history',

    routes

  })

 }
```

## 导航守卫

导航守卫有两种，一种是使用vue-router的路由守卫定义（在router.js中配置），一种是使用nuxt的中间件和插件配置

### router.js配置

- vue-cli中怎么用，nuxt中就怎么用，几乎一样，比如`beforeEach`等
- 但是vue-router中的路由守卫会在服务端和客户执行，执行两次
- 由于会在服务端执行，所以不能在路由守卫中使用客户端的API，比如localstorage。

### nuxtjs配置

- 使用中间件 : middleware

- 使用插件  : plugins (全局)

  - nuxt.config.js进行配置` plugins: [  '~/plugins/router.js' ]`

  -  新建plugins/router.js

    ```js
    export default ({app})=>{
        app.router.beforeEach((to,from,next)=>{
            console.log( to );
            next();
        })
    }
    ```

    

### 服务端不能使用localStorage和cookie的解决方案

参考链接：https://www.npmjs.com/package/cookie-universal-nuxt

- 安装下载`npm i --save cookie-universal-nuxt`

- nuxt.config.js进行配置`modules: [ 'cookie-universal-nuxt']`

## nuxt配置之head

### 全局配置

- 在nuxt.config.js中配置head

  ### 局部配置

> Nuxt.js 使用了 [`vue-meta`](https://github.com/nuxt/vue-meta) 更新应用的 `头部标签(Head)` 和 `html 属性`。

- **类型：** `Object` 或 `Function`

使用 `head` 方法设置当前页面的头部标签。

在 `head` 方法里可通过 `this` 关键字来获取组件的数据，你可以利用页面组件的数据来设置个性化的 `meta` 标签。

```html
<template>
  <h1>{{ title }}</h1>
</template>

<script>
  export default {
    data() {
      return {
        title: 'Hello World!'
      }
    },
    head() {
      return {
        title: this.title,
        meta: [
          {
            hid: 'description',
            name: 'description',
            content: 'My custom description'
          }
        ]
      }
    }
  }
</script>
```

注意：为了避免子组件中的 meta 标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 `hid` 键为 meta 标签配一个唯一的标识编号。请阅读[关于 `vue-meta` 的更多信息](https://vue-meta.nuxtjs.org/api/#tagidkeyname)。

## nuxt配置之Css

> 在 Nuxtjs 里配置全局的 CSS 文件、模块、库。 (每个页面都会被引入)

如果要使用 `sass` 就必须要安装 `node-sass`和`sass-loader` 。

```text
npm install --save-dev node-sass sass-loader
```

在 `nuxt.conf.js`中，添加要使用的 CSS 资源：

- Type: Array
- Items: string

```js
module.exports = {
  css: [
    // 直接加载一个 Node.js 模块。（在这里它是一个 Sass 文件）
    'bulma',
    // 项目里要用的 CSS 文件
    '@/assets/css/main.css',
    // 项目里要使用的 SCSS 文件
    '@/assets/css/main.scss'
  ]
}
```

Nuxt.js 会自动识别被导入文件的扩展名，之后，webpack 会使用相应的预处理器进行处理。前提是，你安装了对应预处理器

## nuxt配置之plugins 

- 类型：

  ```
  Array
  ```

  - 数组元素类型： `String` 或 `Object`

如果数组元素类型是 `Object`， 其具有以下属性：

- src: `String` (文件的路径)
- ssr: `Boolean` (默认为 `true`) *如果值为 false，该文件只会在客户端被打包引入。*

> `plugins` 属性使得你可以轻易地为 Nuxt.js 配置使用 Vue.js 插件。

例如 (`nuxt.config.js`)：

```js
module.exports = {
  plugins: ['~plugins/vue-notifications']
}
```

然后, 我们需要创建 `plugins/vue-notifications.js` 文件：

```js
import Vue from 'vue'
import VueNotifications from 'vue-notifications'

Vue.use(VueNotifications)
```

`plugins` 属性配置的所有插件会在 Nuxt.js 应用初始化之前被加载**导入**。

每次你需要使用 `Vue.use()` 时，你需要在 `plugins/` 目录下创建相应的插件文件，并在 `nuxt.config.js` 中的 `plugins` 配置项中配置插件的路径。

想了解更多关于使用插件的信息，请移步 [插件使用指引](https://www.nuxtjs.cn/guide/plugins#使用-vue-插件)。

## nuxt配置之modules

- 类型: `Array`

> modules 是 Nuxt.js 扩展，可以扩展它的核心功能并添加无限的集成。[了解更多](https://www.nuxtjs.cn/guide/modules)

例如 (`nuxt.config.js`):

```js
export default {
  modules: [
    // Using package name
    '@nuxtjs/axios',

    // Relative to your project srcDir
    '~/modules/awesome.js',

    // Providing options
    ['@nuxtjs/google-analytics', { ua: 'X1234567' }],

    // Inline definition
    function () {}
  ]
}
```

模块开发通常会提供额外需要的步骤和使用细节。

Nuxt.js 尝试使用节点需求路径（在`node_modules`中）解析`modules`数组中的每个项目，如果使用`~`别名，则将从项目`srcDir`中解析。模块按顺序执行，因此顺序很重要。

模块应该导出一个函数来增强**nuxt 构建 / 运行**，并可选择返回一个`promise`，直到它们的工作完成。请注意，它们在运行时是必需的，因此如果依赖于现代`ES6`功能，应该已经进行了转换。

有关它们如何工作或是否有兴趣开发自己的模块的更多详细信息，请参阅[模块指南](https://www.nuxtjs.cn/guide/modules)。此外，我们还提供了一个官方[Modules](https://github.com/nuxt-community/awesome-nuxt#modules)部分，列出了由 Nuxt 社区制作的数十个生产模块。